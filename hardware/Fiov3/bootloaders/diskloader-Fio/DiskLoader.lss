
DiskLoader.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000008  00800100  00007efa  0000078e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000006fa  00007800  00007800  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000093  00800108  00800108  00000796  2**0
                  ALLOC
  3 .debug_aranges 000000b0  00000000  00000000  00000796  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 0000028d  00000000  00000000  00000846  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00001a0b  00000000  00000000  00000ad3  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000059b  00000000  00000000  000024de  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000b5c  00000000  00000000  00002a79  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000120  00000000  00000000  000035d8  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000763  00000000  00000000  000036f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000561  00000000  00000000  00003e5b  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000001a8  00000000  00000000  000043bc  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00007800 <entrypoint>:
		"ldi	r28,	0xFF\n"
		"ldi	r29,	0x0A\n"
		"out	0x3E,	r29\n"	// SPH
		"out	0x3D,	r28\n"	// SPL
		"rjmp	main"			// Stack is all set up, start the main code
		::);
    7800:	11 24       	eor	r1, r1
    7802:	1f be       	out	0x3f, r1	; 63
    7804:	cf ef       	ldi	r28, 0xFF	; 255
    7806:	da e0       	ldi	r29, 0x0A	; 10
    7808:	de bf       	out	0x3e, r29	; 62
    780a:	cd bf       	out	0x3d, r28	; 61
    780c:	fd c0       	rjmp	.+506    	; 0x7a08 <main>

0000780e <_readSize>:
		;
	USBCON = ((1<<USBE)|(1<<OTGPADE));	// start USB clock
	UDCON = 0;							// enable attach resistor
}

u8 USBGetConfiguration(void)
    780e:	41 01 42 14 45 05 56 04 55 02 64 03 74 03 00 00     A.B.E.V.U.d.t...

0000781e <_consts>:
    781e:	1e 95 87 02 01 10 03 00                             ........

00007826 <_initEndpoints>:
    7826:	00 c1 80 81 c1                                      .....

0000782b <_rawHID>:
    782b:	06 c0 ff 0a 00 0c a1 01 85 03 75 08 15 00 26 ff     ..........u...&.
    783b:	00 95 40 09 01 81 02 95 40 09 02 91 02 c0           ..@.....@.....

00007849 <STRING_LANGUAGE>:
    7849:	04 03 09 04                                         ....

0000784d <STRING_SERIAL>:
    784d:	1a 03 30 00 30 00 30 00 30 00 30 00 30 00 30 00     ..0.0.0.0.0.0.0.
    785d:	30 00 31 00 37 00 30 00 31 00                       0.1.7.0.1.

00007867 <STRING_IPRODUCT>:
    7867:	20 03 53 00 70 00 61 00 72 00 6b 00 46 00 75 00      .S.p.a.r.k.F.u.
    7877:	6e 00 20 00 46 00 69 00 6f 00 20 00 76 00 33 00     n. .F.i.o. .v.3.
	...

00007889 <STRING_IMANUFACTURER>:
    7889:	2a 03 53 00 70 00 61 00 72 00 6b 00 46 00 75 00     *.S.p.a.r.k.F.u.
    7899:	6e 00 20 00 45 00 6c 00 65 00 63 00 74 00 72 00     n. .E.l.e.c.t.r.
    78a9:	6f 00 6e 00 69 00 63 00 73 00                       o.n.i.c.s.

000078b3 <USB_DeviceDescriptorA>:
    78b3:	12 01 00 02 02 00 00 40 4f 1b 04 00 00 01 00 02     .......@O.......
    78c3:	03 01                                               ..

000078c5 <USB_DeviceDescriptor>:
    78c5:	12 01 00 02 00 00 00 40 4f 1b 04 00 00 01 00 02     .......@O.......
    78d5:	03 01                                               ..

000078d7 <USB_ConfigDescriptor>:
    78d7:	09 02 64 00 03 01 00 80 32 08 0b 00 02 02 02 01     ..d.....2.......
    78e7:	00 09 04 00 00 01 02 02 00 00 05 24 00 10 01 05     ...........$....
    78f7:	24 01 01 01 04 24 02 02 05 24 06 00 01 07 05 81     $....$...$......
    7907:	03 10 00 40 09 04 01 00 02 0a 00 00 00 07 05 02     ...@............
    7917:	02 40 00 00 07 05 83 02 40 00 00 09 04 02 00 01     .@......@.......
    7927:	03 00 00 00 09 21 01 01 00 01 22 1e 00 07 05 84     .....!....".....
    7937:	03 40 00 40 00                                      .@.@.

0000793c <_Z8LEDPulsev>:

//	Nice breathing LED indicates we are in the firmware
u16 _pulse;
void LEDPulse()
{
	_pulse += 4;
    793c:	20 91 8a 01 	lds	r18, 0x018A
    7940:	30 91 8b 01 	lds	r19, 0x018B
    7944:	2c 5f       	subi	r18, 0xFC	; 252
    7946:	3f 4f       	sbci	r19, 0xFF	; 255
    7948:	30 93 8b 01 	sts	0x018B, r19
    794c:	20 93 8a 01 	sts	0x018A, r18
	u8 p = _pulse >> 9;
    7950:	c9 01       	movw	r24, r18
    7952:	89 2f       	mov	r24, r25
    7954:	99 27       	eor	r25, r25
    7956:	86 95       	lsr	r24
    7958:	98 2f       	mov	r25, r24
	if (p > 63)
    795a:	80 34       	cpi	r24, 0x40	; 64
    795c:	18 f0       	brcs	.+6      	; 0x7964 <_Z8LEDPulsev+0x28>
		p = 127-p;
    795e:	8f e7       	ldi	r24, 0x7F	; 127
    7960:	89 1b       	sub	r24, r25
    7962:	98 2f       	mov	r25, r24
	p += p;
	if (((u8)_pulse) > p)
    7964:	99 0f       	add	r25, r25
    7966:	92 17       	cp	r25, r18
    7968:	10 f4       	brcc	.+4      	; 0x796e <_Z8LEDPulsev+0x32>
		LED0;
    796a:	47 98       	cbi	0x08, 7	; 8
    796c:	08 95       	ret
	else
		LED1;
    796e:	47 9a       	sbi	0x08, 7	; 8
    7970:	08 95       	ret

00007972 <_Z6Rebootv>:
}

void Reboot()
{
	TXLED0;		// switch off the RX and TX LEDs before starting the user sketch
    7972:	5d 9a       	sbi	0x0b, 5	; 11
	RXLED0;
    7974:	28 9a       	sbi	0x05, 0	; 5
	UDCON = 1;		// Detatch USB
    7976:	81 e0       	ldi	r24, 0x01	; 1
    7978:	80 93 e0 00 	sts	0x00E0, r24
	UDIEN = 0;
    797c:	10 92 e2 00 	sts	0x00E2, r1
	asm volatile (	// Reset vector to run firmware
		"clr r30\n"
		"clr r31\n"
		"ijmp\n"
	::);
    7980:	ee 27       	eor	r30, r30
    7982:	ff 27       	eor	r31, r31
    7984:	09 94       	ijmp
}
    7986:	08 95       	ret

00007988 <_Z7Programhth>:
u8 _inSync;
u8 _ok;
extern volatile u8 _ejected;
extern volatile u16 _timeout;

void Program(u8 ep, u16 page, u8 count)
    7988:	0f 93       	push	r16
    798a:	1f 93       	push	r17
    798c:	cf 93       	push	r28
    798e:	df 93       	push	r29
    7990:	98 2f       	mov	r25, r24
    7992:	eb 01       	movw	r28, r22
    7994:	04 2f       	mov	r16, r20
{
	u8 write = page < 30*1024;		// Don't write over firmware please
    7996:	10 e0       	ldi	r17, 0x00	; 0
    7998:	88 e7       	ldi	r24, 0x78	; 120
    799a:	60 30       	cpi	r22, 0x00	; 0
    799c:	78 07       	cpc	r23, r24
    799e:	30 f4       	brcc	.+12     	; 0x79ac <_Z7Programhth+0x24>
    79a0:	11 e0       	ldi	r17, 0x01	; 1
	if (write)
		boot_page_erase(page);
    79a2:	83 e0       	ldi	r24, 0x03	; 3
    79a4:	fb 01       	movw	r30, r22
    79a6:	80 93 57 00 	sts	0x0057, r24
    79aa:	e8 95       	spm

	Recv(ep,_flashbuf,count);		// Read while page is erasing
    79ac:	89 2f       	mov	r24, r25
    79ae:	68 e0       	ldi	r22, 0x08	; 8
    79b0:	71 e0       	ldi	r23, 0x01	; 1
    79b2:	40 2f       	mov	r20, r16
    79b4:	f8 d0       	rcall	.+496    	; 0x7ba6 <_Z4RecvhPhh>

	if (!write)
    79b6:	11 23       	and	r17, r17
    79b8:	11 f1       	breq	.+68     	; 0x79fe <_Z7Programhth+0x76>
		return;

	boot_spm_busy_wait();			// Wait until the memory is erased.
    79ba:	07 b6       	in	r0, 0x37	; 55
    79bc:	00 fc       	sbrc	r0, 0
    79be:	fd cf       	rjmp	.-6      	; 0x79ba <_Z7Programhth+0x32>

	count >>= 1;
    79c0:	40 2f       	mov	r20, r16
    79c2:	46 95       	lsr	r20
	u16* p = (u16*)page;
    79c4:	fe 01       	movw	r30, r28
    79c6:	a8 e0       	ldi	r26, 0x08	; 8
    79c8:	b1 e0       	ldi	r27, 0x01	; 1
    79ca:	20 e0       	ldi	r18, 0x00	; 0
	u16* b = (u16*)_flashbuf;
	for (u8 i = 0; i < count; i++)
		boot_page_fill(p++, b[i]);
    79cc:	31 e0       	ldi	r19, 0x01	; 1
    79ce:	09 c0       	rjmp	.+18     	; 0x79e2 <_Z7Programhth+0x5a>
    79d0:	8d 91       	ld	r24, X+
    79d2:	9d 91       	ld	r25, X+
    79d4:	0c 01       	movw	r0, r24
    79d6:	30 93 57 00 	sts	0x0057, r19
    79da:	e8 95       	spm
    79dc:	11 24       	eor	r1, r1
    79de:	32 96       	adiw	r30, 0x02	; 2
	boot_spm_busy_wait();			// Wait until the memory is erased.

	count >>= 1;
	u16* p = (u16*)page;
	u16* b = (u16*)_flashbuf;
	for (u8 i = 0; i < count; i++)
    79e0:	2f 5f       	subi	r18, 0xFF	; 255
    79e2:	24 17       	cp	r18, r20
    79e4:	a8 f3       	brcs	.-22     	; 0x79d0 <_Z7Programhth+0x48>
		boot_page_fill(p++, b[i]);

    boot_page_write(page);
    79e6:	85 e0       	ldi	r24, 0x05	; 5
    79e8:	fe 01       	movw	r30, r28
    79ea:	80 93 57 00 	sts	0x0057, r24
    79ee:	e8 95       	spm
    boot_spm_busy_wait();
    79f0:	07 b6       	in	r0, 0x37	; 55
    79f2:	00 fc       	sbrc	r0, 0
    79f4:	fd cf       	rjmp	.-6      	; 0x79f0 <_Z7Programhth+0x68>
    boot_rww_enable ();
    79f6:	81 e1       	ldi	r24, 0x11	; 17
    79f8:	80 93 57 00 	sts	0x0057, r24
    79fc:	e8 95       	spm
}
    79fe:	df 91       	pop	r29
    7a00:	cf 91       	pop	r28
    7a02:	1f 91       	pop	r17
    7a04:	0f 91       	pop	r16
    7a06:	08 95       	ret

00007a08 <main>:
int main(void) __attribute__ ((naked));

//	STK500v1 main loop, very similar to optiboot in protocol and implementation
int main()
{
	wdt_disable();
    7a08:	88 e1       	ldi	r24, 0x18	; 24
    7a0a:	0f b6       	in	r0, 0x3f	; 63
    7a0c:	f8 94       	cli
    7a0e:	80 93 60 00 	sts	0x0060, r24
    7a12:	10 92 60 00 	sts	0x0060, r1
    7a16:	0f be       	out	0x3f, r0	; 63
	TXLED0;
    7a18:	5d 9a       	sbi	0x0b, 5	; 11
	RXLED0;
    7a1a:	28 9a       	sbi	0x05, 0	; 5
	LED0;
    7a1c:	47 98       	cbi	0x08, 7	; 8
	BOARD_INIT();
    7a1e:	3f 9a       	sbi	0x07, 7	; 7
    7a20:	20 9a       	sbi	0x04, 0	; 4
    7a22:	55 9a       	sbi	0x0a, 5	; 10
    7a24:	90 e8       	ldi	r25, 0x80	; 128
    7a26:	90 93 61 00 	sts	0x0061, r25
    7a2a:	10 92 61 00 	sts	0x0061, r1
    7a2e:	81 e8       	ldi	r24, 0x81	; 129
    7a30:	85 bf       	out	0x35, r24	; 53
    7a32:	95 bf       	out	0x35, r25	; 53
	USBInit();
    7a34:	9f d0       	rcall	.+318    	; 0x7b74 <_Z7USBInitv>

	_inSync = STK_INSYNC;
    7a36:	84 e1       	ldi	r24, 0x14	; 20
    7a38:	80 93 88 01 	sts	0x0188, r24
	_ok = STK_OK;
    7a3c:	80 e1       	ldi	r24, 0x10	; 16
    7a3e:	80 93 89 01 	sts	0x0189, r24

	if (pgm_read_word(0) != -1)
    7a42:	e0 e0       	ldi	r30, 0x00	; 0
    7a44:	f0 e0       	ldi	r31, 0x00	; 0
    7a46:	85 91       	lpm	r24, Z+
    7a48:	94 91       	lpm	r25, Z+
    7a4a:	8f 5f       	subi	r24, 0xFF	; 255
    7a4c:	9f 4f       	sbci	r25, 0xFF	; 255
    7a4e:	19 f0       	breq	.+6      	; 0x7a56 <main+0x4e>
		_ejected = 1;
    7a50:	81 e0       	ldi	r24, 0x01	; 1
    7a52:	80 93 8f 01 	sts	0x018F, r24
    7a56:	ee 24       	eor	r14, r14
    7a58:	ff 24       	eor	r15, r15
			}

			else if (STK_UNIVERSAL == cmd)
			{
				if (packet[0] == 0x30)
					pgm = _consts + packet[2];	// read signature
    7a5a:	bb 24       	eor	r11, r11
    7a5c:	b3 94       	inc	r11
			Transfer(CDC_TX|TRANSFER_RELEASE,&_ok,1);

			if (cmd == 'Q')
				break;
		}
		_timeout = 500;		// wait a moment before exiting the bootloader - may need to finish responding to 'Q' for example
    7a5e:	54 ef       	ldi	r21, 0xF4	; 244
    7a60:	c5 2e       	mov	r12, r21
    7a62:	51 e0       	ldi	r21, 0x01	; 1
    7a64:	d5 2e       	mov	r13, r21
	{
		u8* packet = _flashbuf;
		u16 address = 0;
		for (;;)
		{
			u8 cmd = getch();
    7a66:	13 d2       	rcall	.+1062   	; 0x7e8e <_Z10USBGetCharv>
    7a68:	08 2f       	mov	r16, r24
    7a6a:	8e e0       	ldi	r24, 0x0E	; 14
    7a6c:	98 e7       	ldi	r25, 0x78	; 120
			//	Read packet contents
			u8 len;
			const u8* rs = _readSize;
			for(;;)
			{
				u8 c = pgm_read_byte(rs++);
    7a6e:	fc 01       	movw	r30, r24
    7a70:	24 91       	lpm	r18, Z+
    7a72:	31 96       	adiw	r30, 0x01	; 1
    7a74:	02 96       	adiw	r24, 0x02	; 2
				len = pgm_read_byte(rs++);
    7a76:	44 91       	lpm	r20, Z+
				if (c == cmd || c == 0)
    7a78:	20 17       	cp	r18, r16
    7a7a:	11 f0       	breq	.+4      	; 0x7a80 <main+0x78>
    7a7c:	22 23       	and	r18, r18
    7a7e:	b9 f7       	brne	.-18     	; 0x7a6e <main+0x66>
					break;
			}
			_timeout = 0;
    7a80:	10 92 91 01 	sts	0x0191, r1
    7a84:	10 92 90 01 	sts	0x0190, r1
			//	Read params
			Recv(CDC_RX,packet,len);
    7a88:	82 e0       	ldi	r24, 0x02	; 2
    7a8a:	68 e0       	ldi	r22, 0x08	; 8
    7a8c:	71 e0       	ldi	r23, 0x01	; 1
    7a8e:	8b d0       	rcall	.+278    	; 0x7ba6 <_Z4RecvhPhh>

			//	Send a response
			u8 send = 0;
			const u8* pgm = _consts+7;			// 0
			if (STK_GET_PARAMETER == cmd)
    7a90:	01 34       	cpi	r16, 0x41	; 65
    7a92:	79 f4       	brne	.+30     	; 0x7ab2 <main+0xaa>
			{
				u8 i = packet[0] - 0x80;
    7a94:	60 91 08 01 	lds	r22, 0x0108
    7a98:	60 58       	subi	r22, 0x80	; 128
				if (i > 2)
    7a9a:	63 30       	cpi	r22, 0x03	; 3
    7a9c:	28 f0       	brcs	.+10     	; 0x7aa8 <main+0xa0>
					i = (i == 0x18) ? 3 : 4;	// 0x80:HW_VER,0x81:SW_MAJOR,0x82:SW_MINOR,0x18:3 or 0
    7a9e:	68 31       	cpi	r22, 0x18	; 24
    7aa0:	11 f0       	breq	.+4      	; 0x7aa6 <main+0x9e>
    7aa2:	64 e0       	ldi	r22, 0x04	; 4
    7aa4:	01 c0       	rjmp	.+2      	; 0x7aa8 <main+0xa0>
    7aa6:	63 e0       	ldi	r22, 0x03	; 3
				pgm = _consts + i + 3;
    7aa8:	c6 2f       	mov	r28, r22
    7aaa:	d0 e0       	ldi	r29, 0x00	; 0
    7aac:	cf 5d       	subi	r28, 0xDF	; 223
    7aae:	d7 48       	sbci	r29, 0x87	; 135
    7ab0:	0e c0       	rjmp	.+28     	; 0x7ace <main+0xc6>
				send = 1;
			}

			else if (STK_UNIVERSAL == cmd)
    7ab2:	06 35       	cpi	r16, 0x56	; 86
    7ab4:	71 f4       	brne	.+28     	; 0x7ad2 <main+0xca>
			{
				if (packet[0] == 0x30)
    7ab6:	80 91 08 01 	lds	r24, 0x0108
    7aba:	80 33       	cpi	r24, 0x30	; 48
    7abc:	11 f0       	breq	.+4      	; 0x7ac2 <main+0xba>
    7abe:	11 e0       	ldi	r17, 0x01	; 1
    7ac0:	22 c0       	rjmp	.+68     	; 0x7b06 <main+0xfe>
					pgm = _consts + packet[2];	// read signature
    7ac2:	80 91 0a 01 	lds	r24, 0x010A
    7ac6:	c8 2f       	mov	r28, r24
    7ac8:	d0 e0       	ldi	r29, 0x00	; 0
    7aca:	c2 5e       	subi	r28, 0xE2	; 226
    7acc:	d7 48       	sbci	r29, 0x87	; 135
    7ace:	11 e0       	ldi	r17, 0x01	; 1
    7ad0:	22 c0       	rjmp	.+68     	; 0x7b16 <main+0x10e>
				send = 1;
			}
			
			//	Read signature bytes
			else if (STK_READ_SIGN == cmd)
    7ad2:	05 37       	cpi	r16, 0x75	; 117
    7ad4:	21 f4       	brne	.+8      	; 0x7ade <main+0xd6>
    7ad6:	13 e0       	ldi	r17, 0x03	; 3
    7ad8:	ce e1       	ldi	r28, 0x1E	; 30
    7ada:	d8 e7       	ldi	r29, 0x78	; 120
    7adc:	1c c0       	rjmp	.+56     	; 0x7b16 <main+0x10e>
			{
				pgm = _consts;
				send = 3;
			}

			else if (STK_LOAD_ADDRESS == cmd)
    7ade:	05 35       	cpi	r16, 0x55	; 85
    7ae0:	39 f4       	brne	.+14     	; 0x7af0 <main+0xe8>
			{
				address = *((u16*)packet);		// word addresses
    7ae2:	e0 90 08 01 	lds	r14, 0x0108
    7ae6:	f0 90 09 01 	lds	r15, 0x0109
				address += address;
    7aea:	ee 0c       	add	r14, r14
    7aec:	ff 1c       	adc	r15, r15
    7aee:	0a c0       	rjmp	.+20     	; 0x7b04 <main+0xfc>
			}

			else if (STK_PROG_PAGE == cmd)
    7af0:	04 36       	cpi	r16, 0x64	; 100
    7af2:	31 f4       	brne	.+12     	; 0x7b00 <main+0xf8>
			{
				Program(CDC_RX,address,packet[1]);
    7af4:	82 e0       	ldi	r24, 0x02	; 2
    7af6:	b7 01       	movw	r22, r14
    7af8:	40 91 09 01 	lds	r20, 0x0109
    7afc:	45 df       	rcall	.-374    	; 0x7988 <_Z7Programhth>
    7afe:	02 c0       	rjmp	.+4      	; 0x7b04 <main+0xfc>
			}

			else if (STK_READ_PAGE == cmd)
    7b00:	04 37       	cpi	r16, 0x74	; 116
    7b02:	21 f0       	breq	.+8      	; 0x7b0c <main+0x104>
    7b04:	10 e0       	ldi	r17, 0x00	; 0
    7b06:	c5 e2       	ldi	r28, 0x25	; 37
    7b08:	d8 e7       	ldi	r29, 0x78	; 120
    7b0a:	05 c0       	rjmp	.+10     	; 0x7b16 <main+0x10e>
			{
				send = packet[1];
    7b0c:	10 91 09 01 	lds	r17, 0x0109
				pgm = (const u8*)address;
    7b10:	e7 01       	movw	r28, r14
				address += send; // not sure of this is required
    7b12:	e1 0e       	add	r14, r17
    7b14:	f1 1c       	adc	r15, r1
			}

			// Check sync
			if (getch() != ' ')
    7b16:	bb d1       	rcall	.+886    	; 0x7e8e <_Z10USBGetCharv>
    7b18:	80 97       	sbiw	r24, 0x20	; 32
    7b1a:	b1 f4       	brne	.+44     	; 0x7b48 <main+0x140>
				break;
			Transfer(CDC_TX,&_inSync,1);
    7b1c:	83 e0       	ldi	r24, 0x03	; 3
    7b1e:	68 e8       	ldi	r22, 0x88	; 136
    7b20:	71 e0       	ldi	r23, 0x01	; 1
    7b22:	41 e0       	ldi	r20, 0x01	; 1
    7b24:	50 e0       	ldi	r21, 0x00	; 0
    7b26:	59 d0       	rcall	.+178    	; 0x7bda <_Z8TransferhPKhi>

			// Send result
			if (send)
    7b28:	11 23       	and	r17, r17
    7b2a:	29 f0       	breq	.+10     	; 0x7b36 <main+0x12e>
				Transfer(CDC_TX|TRANSFER_PGM,pgm,send);	// All from pgm memory
    7b2c:	41 2f       	mov	r20, r17
    7b2e:	50 e0       	ldi	r21, 0x00	; 0
    7b30:	83 e8       	ldi	r24, 0x83	; 131
    7b32:	be 01       	movw	r22, r28
    7b34:	52 d0       	rcall	.+164    	; 0x7bda <_Z8TransferhPKhi>

			//	Send ok
			Transfer(CDC_TX|TRANSFER_RELEASE,&_ok,1);
    7b36:	83 e4       	ldi	r24, 0x43	; 67
    7b38:	69 e8       	ldi	r22, 0x89	; 137
    7b3a:	71 e0       	ldi	r23, 0x01	; 1
    7b3c:	41 e0       	ldi	r20, 0x01	; 1
    7b3e:	50 e0       	ldi	r21, 0x00	; 0
    7b40:	4c d0       	rcall	.+152    	; 0x7bda <_Z8TransferhPKhi>

			if (cmd == 'Q')
    7b42:	01 35       	cpi	r16, 0x51	; 81
    7b44:	09 f0       	breq	.+2      	; 0x7b48 <main+0x140>
    7b46:	8f cf       	rjmp	.-226    	; 0x7a66 <main+0x5e>
				break;
		}
		_timeout = 500;		// wait a moment before exiting the bootloader - may need to finish responding to 'Q' for example
    7b48:	d0 92 91 01 	sts	0x0191, r13
    7b4c:	c0 92 90 01 	sts	0x0190, r12
		_ejected = 1;
    7b50:	b0 92 8f 01 	sts	0x018F, r11
    7b54:	ee 24       	eor	r14, r14
    7b56:	ff 24       	eor	r15, r15
    7b58:	86 cf       	rjmp	.-244    	; 0x7a66 <main+0x5e>

00007b5a <_Z4RecvPVhh>:
	TxLEDPulse = TX_RX_LED_PULSE_MS;
	while (count--)
		UEDATX = *data++;
}

void Recv(volatile u8* data, u8 count)
    7b5a:	fc 01       	movw	r30, r24
{
	RXLED1;					// light the RX LED
    7b5c:	28 98       	cbi	0x05, 0	; 5
	RxLEDPulse = TX_RX_LED_PULSE_MS;
    7b5e:	84 e6       	ldi	r24, 0x64	; 100
    7b60:	80 93 8d 01 	sts	0x018D, r24
    7b64:	04 c0       	rjmp	.+8      	; 0x7b6e <_Z4RecvPVhh+0x14>
	while (count--)
		*data++ = UEDATX;
    7b66:	80 91 f1 00 	lds	r24, 0x00F1
    7b6a:	81 93       	st	Z+, r24
    7b6c:	61 50       	subi	r22, 0x01	; 1

void Recv(volatile u8* data, u8 count)
{
	RXLED1;					// light the RX LED
	RxLEDPulse = TX_RX_LED_PULSE_MS;
	while (count--)
    7b6e:	66 23       	and	r22, r22
    7b70:	d1 f7       	brne	.-12     	; 0x7b66 <_Z4RecvPVhh+0xc>
		*data++ = UEDATX;
}
    7b72:	08 95       	ret

00007b74 <_Z7USBInitv>:
}

//	API
void USBInit(void)
{
	_timeout = 0;
    7b74:	10 92 91 01 	sts	0x0191, r1
    7b78:	10 92 90 01 	sts	0x0190, r1
	_usbConfiguration = 0;
    7b7c:	10 92 8e 01 	sts	0x018E, r1
	_ejected = 0;
    7b80:	10 92 8f 01 	sts	0x018F, r1
	
	UHWCON = 0x01;						// power internal reg (don't need this?)
    7b84:	81 e0       	ldi	r24, 0x01	; 1
    7b86:	80 93 d7 00 	sts	0x00D7, r24
	USBCON = (1<<USBE)|(1<<FRZCLK);		// clock frozen, usb enabled
    7b8a:	80 ea       	ldi	r24, 0xA0	; 160
    7b8c:	80 93 d8 00 	sts	0x00D8, r24
	//PLLCSR = 0x12;						// Need 16 MHz xtal	chchchchanges
	PLLCSR = 0x02;						// Need 8 MHz xtal, PINDV must be 0
    7b90:	82 e0       	ldi	r24, 0x02	; 2
    7b92:	89 bd       	out	0x29, r24	; 41
	while (!(PLLCSR & (1<<PLOCK)))		// wait for lock pll
    7b94:	09 b4       	in	r0, 0x29	; 41
    7b96:	00 fe       	sbrs	r0, 0
    7b98:	fd cf       	rjmp	.-6      	; 0x7b94 <_Z7USBInitv+0x20>
		;
	USBCON = ((1<<USBE)|(1<<OTGPADE));	// start USB clock
    7b9a:	80 e9       	ldi	r24, 0x90	; 144
    7b9c:	80 93 d8 00 	sts	0x00D8, r24
	UDCON = 0;							// enable attach resistor
    7ba0:	10 92 e0 00 	sts	0x00E0, r1
}
    7ba4:	08 95       	ret

00007ba6 <_Z4RecvhPhh>:
	SetEP(ep);
	return ReadWriteAllowed();	// count in fifo
}

int USBGetChar();
void Recv(u8 ep, u8* dst, u8 len)
    7ba6:	fb 01       	movw	r30, r22
	UEDATX = d;
}

static inline void SetEP(u8 ep)
{
	UENUM = ep;
    7ba8:	80 93 e9 00 	sts	0x00E9, r24
}

static inline u8 Recv8()
{
	RXLED1;					// light the RX LED
	RxLEDPulse = TX_RX_LED_PULSE_MS;
    7bac:	24 e6       	ldi	r18, 0x64	; 100
	return UEINTX & (1<<FIFOCON);
}

static inline void ReleaseRX()
{
	UEINTX = 0x6B;	// FIFOCON=0 NAKINI=1 RWAL=1 NAKOUTI=0 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=1
    7bae:	9b e6       	ldi	r25, 0x6B	; 107
    7bb0:	11 c0       	rjmp	.+34     	; 0x7bd4 <_Z4RecvhPhh+0x2e>
	UECONX = (1<<STALLRQ) | (1<<EPEN);
}

static inline u8 ReadWriteAllowed()
{
	return UEINTX & (1<<RWAL);
    7bb2:	80 91 e8 00 	lds	r24, 0x00E8
void Recv(u8 ep, u8* dst, u8 len)
{
	SetEP(ep);
	while (len--)
	{
		while (!ReadWriteAllowed())
    7bb6:	85 ff       	sbrs	r24, 5
    7bb8:	fc cf       	rjmp	.-8      	; 0x7bb2 <_Z4RecvhPhh+0xc>
		*data++ = UEDATX;
}

static inline u8 Recv8()
{
	RXLED1;					// light the RX LED
    7bba:	28 98       	cbi	0x05, 0	; 5
	RxLEDPulse = TX_RX_LED_PULSE_MS;
    7bbc:	20 93 8d 01 	sts	0x018D, r18
	return UEDATX;
    7bc0:	80 91 f1 00 	lds	r24, 0x00F1
	SetEP(ep);
	while (len--)
	{
		while (!ReadWriteAllowed())
			;
		*dst++ = Recv8();
    7bc4:	81 93       	st	Z+, r24
	UECONX = (1<<STALLRQ) | (1<<EPEN);
}

static inline u8 ReadWriteAllowed()
{
	return UEINTX & (1<<RWAL);
    7bc6:	80 91 e8 00 	lds	r24, 0x00E8
	while (len--)
	{
		while (!ReadWriteAllowed())
			;
		*dst++ = Recv8();
		if (!ReadWriteAllowed())	// release empty buffer
    7bca:	85 fd       	sbrc	r24, 5
    7bcc:	02 c0       	rjmp	.+4      	; 0x7bd2 <_Z4RecvhPhh+0x2c>
	return UEINTX & (1<<FIFOCON);
}

static inline void ReleaseRX()
{
	UEINTX = 0x6B;	// FIFOCON=0 NAKINI=1 RWAL=1 NAKOUTI=0 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=1
    7bce:	90 93 e8 00 	sts	0x00E8, r25
    7bd2:	41 50       	subi	r20, 0x01	; 1

int USBGetChar();
void Recv(u8 ep, u8* dst, u8 len)
{
	SetEP(ep);
	while (len--)
    7bd4:	44 23       	and	r20, r20
    7bd6:	69 f7       	brne	.-38     	; 0x7bb2 <_Z4RecvhPhh+0xc>
			;
		*dst++ = Recv8();
		if (!ReadWriteAllowed())	// release empty buffer
			ReleaseRX();
	}
}
    7bd8:	08 95       	ret

00007bda <_Z8TransferhPKhi>:

//	Transmit a packet to endpoint
void Transfer(u8 ep, const u8* data, int len)
    7bda:	98 2f       	mov	r25, r24
    7bdc:	fb 01       	movw	r30, r22
{
	u8 zero = ep & TRANSFER_ZERO;
    7bde:	28 2f       	mov	r18, r24
    7be0:	20 72       	andi	r18, 0x20	; 32
	SetEP(ep & 7);
    7be2:	87 70       	andi	r24, 0x07	; 7
	UEDATX = d;
}

static inline void SetEP(u8 ep)
{
	UENUM = ep;
    7be4:	80 93 e9 00 	sts	0x00E9, r24
}

static inline void Send8(u8 d)
{
	TXLED1;					// light the TX LED
	TxLEDPulse = TX_RX_LED_PULSE_MS;
    7be8:	64 e6       	ldi	r22, 0x64	; 100
	UEINTX = 0x6B;	// FIFOCON=0 NAKINI=1 RWAL=1 NAKOUTI=0 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=1
}

static inline void ReleaseTX()
{
	UEINTX = 0x3A;	// FIFOCON=0 NAKINI=0 RWAL=1 NAKOUTI=1 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=0
    7bea:	3a e3       	ldi	r19, 0x3A	; 58
    7bec:	17 c0       	rjmp	.+46     	; 0x7c1c <_Z8TransferhPKhi+0x42>
	UECONX = (1<<STALLRQ) | (1<<EPEN);
}

static inline u8 ReadWriteAllowed()
{
	return UEINTX & (1<<RWAL);
    7bee:	80 91 e8 00 	lds	r24, 0x00E8
{
	u8 zero = ep & TRANSFER_ZERO;
	SetEP(ep & 7);
	while (len--)
	{
		while (!ReadWriteAllowed())
    7bf2:	85 ff       	sbrs	r24, 5
    7bf4:	fc cf       	rjmp	.-8      	; 0x7bee <_Z8TransferhPKhi+0x14>
			;	// TODO Check for STALL etc

		u8 d = (ep & TRANSFER_PGM) ? pgm_read_byte(data) : data[0];
    7bf6:	97 ff       	sbrs	r25, 7
    7bf8:	02 c0       	rjmp	.+4      	; 0x7bfe <_Z8TransferhPKhi+0x24>
    7bfa:	84 91       	lpm	r24, Z+
    7bfc:	01 c0       	rjmp	.+2      	; 0x7c00 <_Z8TransferhPKhi+0x26>
    7bfe:	80 81       	ld	r24, Z
		data++;
    7c00:	31 96       	adiw	r30, 0x01	; 1
		if (zero)
    7c02:	21 11       	cpse	r18, r1
    7c04:	80 e0       	ldi	r24, 0x00	; 0
	return UEDATX;
}

static inline void Send8(u8 d)
{
	TXLED1;					// light the TX LED
    7c06:	5d 98       	cbi	0x0b, 5	; 11
	TxLEDPulse = TX_RX_LED_PULSE_MS;
    7c08:	60 93 8c 01 	sts	0x018C, r22
	UEDATX = d;
    7c0c:	80 93 f1 00 	sts	0x00F1, r24
	UECONX = (1<<STALLRQ) | (1<<EPEN);
}

static inline u8 ReadWriteAllowed()
{
	return UEINTX & (1<<RWAL);
    7c10:	80 91 e8 00 	lds	r24, 0x00E8
		data++;
		if (zero)
			d = 0;
		Send8(d);

		if (!ReadWriteAllowed())
    7c14:	85 fd       	sbrc	r24, 5
    7c16:	02 c0       	rjmp	.+4      	; 0x7c1c <_Z8TransferhPKhi+0x42>
	UEINTX = 0x6B;	// FIFOCON=0 NAKINI=1 RWAL=1 NAKOUTI=0 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=1
}

static inline void ReleaseTX()
{
	UEINTX = 0x3A;	// FIFOCON=0 NAKINI=0 RWAL=1 NAKOUTI=1 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=0
    7c18:	30 93 e8 00 	sts	0x00E8, r19
//	Transmit a packet to endpoint
void Transfer(u8 ep, const u8* data, int len)
{
	u8 zero = ep & TRANSFER_ZERO;
	SetEP(ep & 7);
	while (len--)
    7c1c:	41 50       	subi	r20, 0x01	; 1
    7c1e:	50 40       	sbci	r21, 0x00	; 0
    7c20:	8f ef       	ldi	r24, 0xFF	; 255
    7c22:	4f 3f       	cpi	r20, 0xFF	; 255
    7c24:	58 07       	cpc	r21, r24
    7c26:	19 f7       	brne	.-58     	; 0x7bee <_Z8TransferhPKhi+0x14>
		Send8(d);

		if (!ReadWriteAllowed())
			ReleaseTX();
	}
	if (ep & TRANSFER_RELEASE)
    7c28:	96 ff       	sbrs	r25, 6
    7c2a:	03 c0       	rjmp	.+6      	; 0x7c32 <_Z8TransferhPKhi+0x58>
	UEINTX = 0x6B;	// FIFOCON=0 NAKINI=1 RWAL=1 NAKOUTI=0 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=1
}

static inline void ReleaseTX()
{
	UEINTX = 0x3A;	// FIFOCON=0 NAKINI=0 RWAL=1 NAKOUTI=1 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=0
    7c2c:	8a e3       	ldi	r24, 0x3A	; 58
    7c2e:	80 93 e8 00 	sts	0x00E8, r24
    7c32:	08 95       	ret

00007c34 <_Z7USBHookv>:

//bool USBHook(Setup& setup)
bool USBHook()
{
	Setup& setup = _setup;
	u8 r = setup.bRequest;
    7c34:	80 91 93 01 	lds	r24, 0x0193

	//	CDC Requests
	if (CDC_GET_LINE_CODING == r)
    7c38:	81 32       	cpi	r24, 0x21	; 33
    7c3a:	99 f4       	brne	.+38     	; 0x7c62 <_Z7USBHookv+0x2e>
}

static
void Send(volatile const u8* data, u8 count)
{
	TXLED1;					// light the TX LED
    7c3c:	5d 98       	cbi	0x0b, 5	; 11
	TxLEDPulse = TX_RX_LED_PULSE_MS;
    7c3e:	84 e6       	ldi	r24, 0x64	; 100
    7c40:	80 93 8c 01 	sts	0x018C, r24
    7c44:	20 e0       	ldi	r18, 0x00	; 0
    7c46:	30 e0       	ldi	r19, 0x00	; 0
    7c48:	03 c0       	rjmp	.+6      	; 0x7c50 <_Z7USBHookv+0x1c>
	while (count--)
		UEDATX = *data++;
    7c4a:	80 81       	ld	r24, Z
    7c4c:	80 93 f1 00 	sts	0x00F1, r24
    7c50:	f9 01       	movw	r30, r18
    7c52:	e0 50       	subi	r30, 0x00	; 0
    7c54:	ff 4f       	sbci	r31, 0xFF	; 255
    7c56:	2f 5f       	subi	r18, 0xFF	; 255
    7c58:	3f 4f       	sbci	r19, 0xFF	; 255
static
void Send(volatile const u8* data, u8 count)
{
	TXLED1;					// light the TX LED
	TxLEDPulse = TX_RX_LED_PULSE_MS;
	while (count--)
    7c5a:	28 30       	cpi	r18, 0x08	; 8
    7c5c:	31 05       	cpc	r19, r1
    7c5e:	a9 f7       	brne	.-22     	; 0x7c4a <_Z7USBHookv+0x16>
    7c60:	14 c0       	rjmp	.+40     	; 0x7c8a <_Z7USBHookv+0x56>
	if (CDC_GET_LINE_CODING == r)
	{
		Send((const volatile u8*)&_usbLineInfo,7);
	}

	else if (CDC_SET_LINE_CODING ==  r)
    7c62:	80 32       	cpi	r24, 0x20	; 32
    7c64:	61 f4       	brne	.+24     	; 0x7c7e <_Z7USBHookv+0x4a>
	UEINTX = ~(1<<TXINI);
}

static inline void WaitOUT(void)
{
	while (!(UEINTX & (1<<RXOUTI)))
    7c66:	80 91 e8 00 	lds	r24, 0x00E8
    7c6a:	82 ff       	sbrs	r24, 2
    7c6c:	fc cf       	rjmp	.-8      	; 0x7c66 <_Z7USBHookv+0x32>
	}

	else if (CDC_SET_LINE_CODING ==  r)
	{
		WaitOUT();
		Recv((volatile u8*)&_usbLineInfo,7);
    7c6e:	80 e0       	ldi	r24, 0x00	; 0
    7c70:	91 e0       	ldi	r25, 0x01	; 1
    7c72:	67 e0       	ldi	r22, 0x07	; 7
    7c74:	72 df       	rcall	.-284    	; 0x7b5a <_Z4RecvPVhh>
	return (UEINTX & (1<<RXOUTI)) == 0;
}

static inline void ClearOUT(void)
{
	UEINTX = ~(1<<RXOUTI);
    7c76:	8b ef       	ldi	r24, 0xFB	; 251
    7c78:	80 93 e8 00 	sts	0x00E8, r24
    7c7c:	06 c0       	rjmp	.+12     	; 0x7c8a <_Z7USBHookv+0x56>
		WaitOUT();
		Recv((volatile u8*)&_usbLineInfo,7);
		ClearOUT();
	}

	else if (CDC_SET_CONTROL_LINE_STATE == r)
    7c7e:	82 32       	cpi	r24, 0x22	; 34
    7c80:	21 f4       	brne	.+8      	; 0x7c8a <_Z7USBHookv+0x56>
	{
		_usbLineInfo.lineState = setup.wValueL;
    7c82:	80 91 94 01 	lds	r24, 0x0194
    7c86:	80 93 07 01 	sts	0x0107, r24
	}

	return true;
}
    7c8a:	81 e0       	ldi	r24, 0x01	; 1
    7c8c:	08 95       	ret

00007c8e <_Z14SendDescriptorv>:
{
	Setup& setup = _setup;
	u8 desc_length = 0;
	const u8* desc_addr = 0;

	u8 t = setup.wValueH;
    7c8e:	20 91 95 01 	lds	r18, 0x0195
	if (0x22 == t)
    7c92:	22 32       	cpi	r18, 0x22	; 34
    7c94:	89 f1       	breq	.+98     	; 0x7cf8 <_Z14SendDescriptorv+0x6a>
	{
		desc_addr = _rawHID;
		desc_length = sizeof(desc_length);
	} else if (USB_DEVICE_DESCRIPTOR_TYPE == t)
    7c96:	21 30       	cpi	r18, 0x01	; 1
    7c98:	81 f4       	brne	.+32     	; 0x7cba <_Z14SendDescriptorv+0x2c>
	{
		if (setup.wLength == 8)
    7c9a:	80 91 98 01 	lds	r24, 0x0198
    7c9e:	90 91 99 01 	lds	r25, 0x0199
    7ca2:	08 97       	sbiw	r24, 0x08	; 8
    7ca4:	11 f4       	brne	.+4      	; 0x7caa <_Z14SendDescriptorv+0x1c>
			_cdcComposite = 1;
    7ca6:	20 93 9a 01 	sts	0x019A, r18
		desc_addr = _cdcComposite ?  (const u8*)&USB_DeviceDescriptorA : (const u8*)&USB_DeviceDescriptor;
    7caa:	80 91 9a 01 	lds	r24, 0x019A
    7cae:	88 23       	and	r24, r24
    7cb0:	09 f0       	breq	.+2      	; 0x7cb4 <_Z14SendDescriptorv+0x26>
    7cb2:	4f c0       	rjmp	.+158    	; 0x7d52 <_Z14SendDescriptorv+0xc4>
    7cb4:	e5 ec       	ldi	r30, 0xC5	; 197
    7cb6:	f8 e7       	ldi	r31, 0x78	; 120
    7cb8:	4e c0       	rjmp	.+156    	; 0x7d56 <_Z14SendDescriptorv+0xc8>
	}
	else if (USB_CONFIGURATION_DESCRIPTOR_TYPE == t)
    7cba:	22 30       	cpi	r18, 0x02	; 2
    7cbc:	21 f4       	brne	.+8      	; 0x7cc6 <_Z14SendDescriptorv+0x38>
    7cbe:	84 e6       	ldi	r24, 0x64	; 100
    7cc0:	e7 ed       	ldi	r30, 0xD7	; 215
    7cc2:	f8 e7       	ldi	r31, 0x78	; 120
    7cc4:	1c c0       	rjmp	.+56     	; 0x7cfe <_Z14SendDescriptorv+0x70>
	{
		desc_addr = (const u8*)&USB_ConfigDescriptor;
		desc_length = sizeof(USB_ConfigDescriptor);
	}
	else if (USB_STRING_DESCRIPTOR_TYPE == t)
    7cc6:	23 30       	cpi	r18, 0x03	; 3
    7cc8:	09 f0       	breq	.+2      	; 0x7ccc <_Z14SendDescriptorv+0x3e>
    7cca:	41 c0       	rjmp	.+130    	; 0x7d4e <_Z14SendDescriptorv+0xc0>
	{
		if (setup.wValueL == 0)
    7ccc:	80 91 94 01 	lds	r24, 0x0194
    7cd0:	88 23       	and	r24, r24
    7cd2:	19 f4       	brne	.+6      	; 0x7cda <_Z14SendDescriptorv+0x4c>
			desc_addr = (const u8*)&STRING_LANGUAGE;
    7cd4:	e9 e4       	ldi	r30, 0x49	; 73
    7cd6:	f8 e7       	ldi	r31, 0x78	; 120
    7cd8:	3e c0       	rjmp	.+124    	; 0x7d56 <_Z14SendDescriptorv+0xc8>
		else if (setup.wValueL == IPRODUCT) 
    7cda:	82 30       	cpi	r24, 0x02	; 2
    7cdc:	19 f4       	brne	.+6      	; 0x7ce4 <_Z14SendDescriptorv+0x56>
			desc_addr = (const u8*)&STRING_IPRODUCT;
    7cde:	e7 e6       	ldi	r30, 0x67	; 103
    7ce0:	f8 e7       	ldi	r31, 0x78	; 120
    7ce2:	39 c0       	rjmp	.+114    	; 0x7d56 <_Z14SendDescriptorv+0xc8>
		else if (setup.wValueL == ISERIAL)
    7ce4:	83 30       	cpi	r24, 0x03	; 3
    7ce6:	19 f4       	brne	.+6      	; 0x7cee <_Z14SendDescriptorv+0x60>
			desc_addr = (const u8*)&STRING_SERIAL;
    7ce8:	ed e4       	ldi	r30, 0x4D	; 77
    7cea:	f8 e7       	ldi	r31, 0x78	; 120
    7cec:	34 c0       	rjmp	.+104    	; 0x7d56 <_Z14SendDescriptorv+0xc8>
		else if (setup.wValueL == IMANUFACTURER)
    7cee:	81 30       	cpi	r24, 0x01	; 1
    7cf0:	71 f5       	brne	.+92     	; 0x7d4e <_Z14SendDescriptorv+0xc0>
			desc_addr = (const u8*)&STRING_IMANUFACTURER;
    7cf2:	e9 e8       	ldi	r30, 0x89	; 137
    7cf4:	f8 e7       	ldi	r31, 0x78	; 120
    7cf6:	2f c0       	rjmp	.+94     	; 0x7d56 <_Z14SendDescriptorv+0xc8>
    7cf8:	81 e0       	ldi	r24, 0x01	; 1
    7cfa:	eb e2       	ldi	r30, 0x2B	; 43
    7cfc:	f8 e7       	ldi	r31, 0x78	; 120
    7cfe:	90 91 98 01 	lds	r25, 0x0198
    7d02:	38 2f       	mov	r19, r24
    7d04:	98 17       	cp	r25, r24
    7d06:	08 f4       	brcc	.+2      	; 0x7d0a <_Z14SendDescriptorv+0x7c>
    7d08:	39 2f       	mov	r19, r25
    7d0a:	90 91 8c 01 	lds	r25, 0x018C
    7d0e:	20 e0       	ldi	r18, 0x00	; 0
	while (!(UEINTX & (1<<TXINI)));
}

static inline void ClearIN(void)
{
	UEINTX = ~(1<<TXINI);
    7d10:	4e ef       	ldi	r20, 0xFE	; 254
		;
}

static inline u8 WaitForINOrOUT()
{
	while (!(UEINTX & ((1<<TXINI)|(1<<RXOUTI))))
    7d12:	80 91 e8 00 	lds	r24, 0x00E8
    7d16:	85 70       	andi	r24, 0x05	; 5
    7d18:	e1 f3       	breq	.-8      	; 0x7d12 <_Z14SendDescriptorv+0x84>
		;
	return (UEINTX & (1<<RXOUTI)) == 0;
    7d1a:	80 91 e8 00 	lds	r24, 0x00E8
	//	EP0 is 64 bytes long
	//	RWAL and FIFOCON don't work on EP0
	u8 n = 0;
	do
	{
		if (!WaitForINOrOUT())
    7d1e:	82 fd       	sbrc	r24, 2
    7d20:	12 c0       	rjmp	.+36     	; 0x7d46 <_Z14SendDescriptorv+0xb8>
			return false;
		Send8(pgm_read_byte(&desc_addr[n++]));
    7d22:	2f 5f       	subi	r18, 0xFF	; 255
    7d24:	84 91       	lpm	r24, Z+
	return UEDATX;
}

static inline void Send8(u8 d)
{
	TXLED1;					// light the TX LED
    7d26:	5d 98       	cbi	0x0b, 5	; 11
	TxLEDPulse = TX_RX_LED_PULSE_MS;
	UEDATX = d;
    7d28:	80 93 f1 00 	sts	0x00F1, r24
	{
		if (!WaitForINOrOUT())
			return false;
		Send8(pgm_read_byte(&desc_addr[n++]));
		u8 clr = n & 0x3F;
		if (!clr)
    7d2c:	82 2f       	mov	r24, r18
    7d2e:	8f 73       	andi	r24, 0x3F	; 63
    7d30:	11 f4       	brne	.+4      	; 0x7d36 <_Z14SendDescriptorv+0xa8>
	while (!(UEINTX & (1<<TXINI)));
}

static inline void ClearIN(void)
{
	UEINTX = ~(1<<TXINI);
    7d32:	40 93 e8 00 	sts	0x00E8, r20
    7d36:	31 96       	adiw	r30, 0x01	; 1
    7d38:	94 e6       	ldi	r25, 0x64	; 100

	//	Send descriptor
	//	EP0 is 64 bytes long
	//	RWAL and FIFOCON don't work on EP0
	u8 n = 0;
	do
    7d3a:	23 17       	cp	r18, r19
    7d3c:	50 f3       	brcs	.-44     	; 0x7d12 <_Z14SendDescriptorv+0x84>
    7d3e:	90 93 8c 01 	sts	0x018C, r25
    7d42:	81 e0       	ldi	r24, 0x01	; 1
    7d44:	08 95       	ret
    7d46:	90 93 8c 01 	sts	0x018C, r25
    7d4a:	80 e0       	ldi	r24, 0x00	; 0
    7d4c:	08 95       	ret
    7d4e:	80 e0       	ldi	r24, 0x00	; 0
		u8 clr = n & 0x3F;
		if (!clr)
			ClearIN();	// Fifo is full, release this packet
	} while (n < desc_length);
	return true;
}
    7d50:	08 95       	ret

	//	Send descriptor
	//	EP0 is 64 bytes long
	//	RWAL and FIFOCON don't work on EP0
	u8 n = 0;
	do
    7d52:	e3 eb       	ldi	r30, 0xB3	; 179
    7d54:	f8 e7       	ldi	r31, 0x78	; 120
			return false;
	} else 
		return false;

	if (desc_length == 0)
		desc_length = pgm_read_byte(desc_addr);
    7d56:	84 91       	lpm	r24, Z+
    7d58:	d2 cf       	rjmp	.-92     	; 0x7cfe <_Z14SendDescriptorv+0x70>

00007d5a <_Z17USBSetupInterruptv>:
	UEDATX = d;
}

static inline void SetEP(u8 ep)
{
	UENUM = ep;
    7d5a:	10 92 e9 00 	sts	0x00E9, r1
	return UEBCLX;
}

static inline u8 ReceivedSetupInt()
{
	return UEINTX & (1<<RXSTPI);
    7d5e:	80 91 e8 00 	lds	r24, 0x00E8
}

void USBSetupInterrupt()
{
    SetEP(0);
	if (!ReceivedSetupInt())
    7d62:	83 ff       	sbrs	r24, 3
    7d64:	61 c0       	rjmp	.+194    	; 0x7e28 <_Z17USBSetupInterruptv+0xce>
		return;

	Setup& setup = _setup;	// global saves ~30 bytes
	Recv((u8*)&setup,8);
    7d66:	82 e9       	ldi	r24, 0x92	; 146
    7d68:	91 e0       	ldi	r25, 0x01	; 1
    7d6a:	68 e0       	ldi	r22, 0x08	; 8
    7d6c:	f6 de       	rcall	.-532    	; 0x7b5a <_Z4RecvPVhh>
	return UEINTX & (1<<RXSTPI);
}

static inline void ClearSetupInt()
{
	UEINTX = ~((1<<RXSTPI) | (1<<RXOUTI) | (1<<TXINI));
    7d6e:	82 ef       	ldi	r24, 0xF2	; 242
    7d70:	80 93 e8 00 	sts	0x00E8, r24

	Setup& setup = _setup;	// global saves ~30 bytes
	Recv((u8*)&setup,8);
	ClearSetupInt();

	if (setup.bmRequestType & DEVICETOHOST)
    7d74:	80 91 92 01 	lds	r24, 0x0192
    7d78:	87 ff       	sbrs	r24, 7
    7d7a:	05 c0       	rjmp	.+10     	; 0x7d86 <_Z17USBSetupInterruptv+0x2c>
volatile u8 _ejected;
volatile u16 _timeout;

static inline void WaitIN(void)
{
	while (!(UEINTX & (1<<TXINI)));
    7d7c:	80 91 e8 00 	lds	r24, 0x00E8
    7d80:	80 ff       	sbrs	r24, 0
    7d82:	fc cf       	rjmp	.-8      	; 0x7d7c <_Z17USBSetupInterruptv+0x22>
    7d84:	03 c0       	rjmp	.+6      	; 0x7d8c <_Z17USBSetupInterruptv+0x32>
}

static inline void ClearIN(void)
{
	UEINTX = ~(1<<TXINI);
    7d86:	8e ef       	ldi	r24, 0xFE	; 254
    7d88:	80 93 e8 00 	sts	0x00E8, r24
		WaitIN();
	else
		ClearIN();

    bool ok = true;
	u8 r = setup.bRequest;
    7d8c:	80 91 93 01 	lds	r24, 0x0193
	if (SET_ADDRESS == r)
    7d90:	85 30       	cpi	r24, 0x05	; 5
    7d92:	51 f4       	brne	.+20     	; 0x7da8 <_Z17USBSetupInterruptv+0x4e>
volatile u8 _ejected;
volatile u16 _timeout;

static inline void WaitIN(void)
{
	while (!(UEINTX & (1<<TXINI)));
    7d94:	80 91 e8 00 	lds	r24, 0x00E8
    7d98:	80 ff       	sbrs	r24, 0
    7d9a:	fc cf       	rjmp	.-8      	; 0x7d94 <_Z17USBSetupInterruptv+0x3a>
    bool ok = true;
	u8 r = setup.bRequest;
	if (SET_ADDRESS == r)
	{
		WaitIN();
		UDADDR = setup.wValueL | (1<<ADDEN);
    7d9c:	80 91 94 01 	lds	r24, 0x0194
    7da0:	80 68       	ori	r24, 0x80	; 128
    7da2:	80 93 e3 00 	sts	0x00E3, r24
    7da6:	39 c0       	rjmp	.+114    	; 0x7e1a <_Z17USBSetupInterruptv+0xc0>
	}
	else if (SET_CONFIGURATION == r)
    7da8:	89 30       	cpi	r24, 0x09	; 9
    7daa:	e1 f4       	brne	.+56     	; 0x7de4 <_Z17USBSetupInterruptv+0x8a>
	{
		_usbConfiguration = setup.wValueL;
    7dac:	80 91 94 01 	lds	r24, 0x0194
    7db0:	80 93 8e 01 	sts	0x018E, r24
    7db4:	e7 e2       	ldi	r30, 0x27	; 39
    7db6:	f8 e7       	ldi	r31, 0x78	; 120
    7db8:	91 e0       	ldi	r25, 0x01	; 1
static void InitEndpoints()
{
	for (u8 i = 1; i < sizeof(_initEndpoints); i++)
	{
		UENUM = i;
		UECONX = 1;
    7dba:	31 e0       	ldi	r19, 0x01	; 1
		UECFG0X = pgm_read_byte(_initEndpoints+i);
		UECFG1X = EP_DOUBLE_64;
    7dbc:	26 e3       	ldi	r18, 0x36	; 54

static void InitEndpoints()
{
	for (u8 i = 1; i < sizeof(_initEndpoints); i++)
	{
		UENUM = i;
    7dbe:	90 93 e9 00 	sts	0x00E9, r25
		UECONX = 1;
    7dc2:	30 93 eb 00 	sts	0x00EB, r19
		UECFG0X = pgm_read_byte(_initEndpoints+i);
    7dc6:	84 91       	lpm	r24, Z+
    7dc8:	80 93 ec 00 	sts	0x00EC, r24
		UECFG1X = EP_DOUBLE_64;
    7dcc:	20 93 ed 00 	sts	0x00ED, r18
	EP_TYPE_INTERRUPT_IN,		// HID_ENDPOINT_INT
};

static void InitEndpoints()
{
	for (u8 i = 1; i < sizeof(_initEndpoints); i++)
    7dd0:	9f 5f       	subi	r25, 0xFF	; 255
    7dd2:	31 96       	adiw	r30, 0x01	; 1
    7dd4:	95 30       	cpi	r25, 0x05	; 5
    7dd6:	99 f7       	brne	.-26     	; 0x7dbe <_Z17USBSetupInterruptv+0x64>
		UENUM = i;
		UECONX = 1;
		UECFG0X = pgm_read_byte(_initEndpoints+i);
		UECFG1X = EP_DOUBLE_64;
	}
	UERST = 0x7E;	// And reset them
    7dd8:	8e e7       	ldi	r24, 0x7E	; 126
    7dda:	80 93 ea 00 	sts	0x00EA, r24
	UERST = 0;
    7dde:	10 92 ea 00 	sts	0x00EA, r1
    7de2:	1b c0       	rjmp	.+54     	; 0x7e1a <_Z17USBSetupInterruptv+0xc0>
	else if (SET_CONFIGURATION == r)
	{
		_usbConfiguration = setup.wValueL;
		InitEndpoints();
	}
	else if (GET_CONFIGURATION == r)
    7de4:	88 30       	cpi	r24, 0x08	; 8
    7de6:	49 f4       	brne	.+18     	; 0x7dfa <_Z17USBSetupInterruptv+0xa0>
	{
		Send8(_usbConfiguration);
    7de8:	90 91 8e 01 	lds	r25, 0x018E
	return UEDATX;
}

static inline void Send8(u8 d)
{
	TXLED1;					// light the TX LED
    7dec:	5d 98       	cbi	0x0b, 5	; 11
	TxLEDPulse = TX_RX_LED_PULSE_MS;
    7dee:	84 e6       	ldi	r24, 0x64	; 100
    7df0:	80 93 8c 01 	sts	0x018C, r24
	UEDATX = d;
    7df4:	90 93 f1 00 	sts	0x00F1, r25
    7df8:	10 c0       	rjmp	.+32     	; 0x7e1a <_Z17USBSetupInterruptv+0xc0>
	}
	else if (GET_CONFIGURATION == r)
	{
		Send8(_usbConfiguration);
	}
	else if (GET_STATUS == r)
    7dfa:	88 23       	and	r24, r24
    7dfc:	39 f4       	brne	.+14     	; 0x7e0c <_Z17USBSetupInterruptv+0xb2>
	return UEDATX;
}

static inline void Send8(u8 d)
{
	TXLED1;					// light the TX LED
    7dfe:	5d 98       	cbi	0x0b, 5	; 11
	TxLEDPulse = TX_RX_LED_PULSE_MS;
    7e00:	84 e6       	ldi	r24, 0x64	; 100
    7e02:	80 93 8c 01 	sts	0x018C, r24
	UEDATX = d;
    7e06:	10 92 f1 00 	sts	0x00F1, r1
    7e0a:	07 c0       	rjmp	.+14     	; 0x7e1a <_Z17USBSetupInterruptv+0xc0>
	}
	else if (GET_STATUS == r)
	{
		Send8(0);		// All good as far as I know
	}
	else if (GET_DESCRIPTOR == r)
    7e0c:	86 30       	cpi	r24, 0x06	; 6
    7e0e:	11 f4       	brne	.+4      	; 0x7e14 <_Z17USBSetupInterruptv+0xba>
	{
		ok = SendDescriptor();
    7e10:	3e df       	rcall	.-388    	; 0x7c8e <_Z14SendDescriptorv>
    7e12:	01 c0       	rjmp	.+2      	; 0x7e16 <_Z17USBSetupInterruptv+0xbc>
	}
	else
	{
		ok = USBHook();
    7e14:	0f df       	rcall	.-482    	; 0x7c34 <_Z7USBHookv>
	}

	if (ok)
    7e16:	88 23       	and	r24, r24
    7e18:	21 f0       	breq	.+8      	; 0x7e22 <_Z17USBSetupInterruptv+0xc8>
	while (!(UEINTX & (1<<TXINI)));
}

static inline void ClearIN(void)
{
	UEINTX = ~(1<<TXINI);
    7e1a:	8e ef       	ldi	r24, 0xFE	; 254
    7e1c:	80 93 e8 00 	sts	0x00E8, r24
    7e20:	08 95       	ret
	UEINTX = ~((1<<RXSTPI) | (1<<RXOUTI) | (1<<TXINI));
}

static inline void Stall()
{
	UECONX = (1<<STALLRQ) | (1<<EPEN);
    7e22:	81 e2       	ldi	r24, 0x21	; 33
    7e24:	80 93 eb 00 	sts	0x00EB, r24
    7e28:	08 95       	ret

00007e2a <_Z19USBGeneralInterruptv>:
		Stall();
}

void USBGeneralInterrupt()
{
	u8 udint = UDINT;
    7e2a:	80 91 e1 00 	lds	r24, 0x00E1
	UDINT = 0;
    7e2e:	10 92 e1 00 	sts	0x00E1, r1

	//	End of Reset
	if (udint & (1<<EORSTI))
    7e32:	28 2f       	mov	r18, r24
    7e34:	83 ff       	sbrs	r24, 3
    7e36:	0c c0       	rjmp	.+24     	; 0x7e50 <_Z19USBGeneralInterruptv+0x26>
#define EP_SINGLE_64 0x32	// EP0
#define EP_DOUBLE_64 0x36	// Other endpoints

static void InitEP(u8 index, u8 type, u8 size)
{
	UENUM = index;
    7e38:	10 92 e9 00 	sts	0x00E9, r1
	UECONX = 1;
    7e3c:	81 e0       	ldi	r24, 0x01	; 1
    7e3e:	80 93 eb 00 	sts	0x00EB, r24
	UECFG0X = type;
    7e42:	10 92 ec 00 	sts	0x00EC, r1
	UECFG1X = size;
    7e46:	82 e3       	ldi	r24, 0x32	; 50
    7e48:	80 93 ed 00 	sts	0x00ED, r24

	//	End of Reset
	if (udint & (1<<EORSTI))
	{
		InitEP(0,EP_TYPE_CONTROL,EP_SINGLE_64);	// init ep0
		_usbConfiguration = 0;			// not configured yet
    7e4c:	10 92 8e 01 	sts	0x018E, r1
	}

	//	Start of Frame - happens every millisecond so we use it for TX and RX LED one-shot timing, too
	if (udint & (1<<SOFI))
    7e50:	22 ff       	sbrs	r18, 2
    7e52:	1c c0       	rjmp	.+56     	; 0x7e8c <_Z19USBGeneralInterruptv+0x62>
	{
		// check whether the one-shot period has elapsed.  if so, turn off the LED
		if (TxLEDPulse && !(--TxLEDPulse))
    7e54:	80 91 8c 01 	lds	r24, 0x018C
    7e58:	88 23       	and	r24, r24
    7e5a:	31 f0       	breq	.+12     	; 0x7e68 <_Z19USBGeneralInterruptv+0x3e>
    7e5c:	81 50       	subi	r24, 0x01	; 1
    7e5e:	80 93 8c 01 	sts	0x018C, r24
    7e62:	88 23       	and	r24, r24
    7e64:	09 f4       	brne	.+2      	; 0x7e68 <_Z19USBGeneralInterruptv+0x3e>
			TXLED0;
    7e66:	5d 9a       	sbi	0x0b, 5	; 11
		if (RxLEDPulse && !(--RxLEDPulse))
    7e68:	80 91 8d 01 	lds	r24, 0x018D
    7e6c:	88 23       	and	r24, r24
    7e6e:	31 f0       	breq	.+12     	; 0x7e7c <_Z19USBGeneralInterruptv+0x52>
    7e70:	81 50       	subi	r24, 0x01	; 1
    7e72:	80 93 8d 01 	sts	0x018D, r24
    7e76:	88 23       	and	r24, r24
    7e78:	09 f4       	brne	.+2      	; 0x7e7c <_Z19USBGeneralInterruptv+0x52>
			RXLED0;
    7e7a:	28 9a       	sbi	0x05, 0	; 5
		
		if (!_ejected)
    7e7c:	80 91 8f 01 	lds	r24, 0x018F
    7e80:	88 23       	and	r24, r24
    7e82:	21 f4       	brne	.+8      	; 0x7e8c <_Z19USBGeneralInterruptv+0x62>
			_timeout = 0;
    7e84:	10 92 91 01 	sts	0x0191, r1
    7e88:	10 92 90 01 	sts	0x0190, r1
    7e8c:	08 95       	ret

00007e8e <_Z10USBGetCharv>:
	}
}

void LEDPulse();
int USBGetChar()
    7e8e:	1f 93       	push	r17
    7e90:	cf 93       	push	r28
    7e92:	df 93       	push	r29
	UEDATX = d;
}

static inline void SetEP(u8 ep)
{
	UENUM = ep;
    7e94:	12 e0       	ldi	r17, 0x02	; 2
	__asm__ volatile (
		"1: sbiw %0,1" "\n\t"
		"brne 1b"
		: "=w" (__count)
		: "0" (__count)
	);
    7e96:	c8 ec       	ldi	r28, 0xC8	; 200
    7e98:	d0 e0       	ldi	r29, 0x00	; 0
void LEDPulse();
int USBGetChar()
{
	for(;;)
	{
		USBSetupInterrupt();
    7e9a:	5f df       	rcall	.-322    	; 0x7d5a <_Z17USBSetupInterruptv>
		USBGeneralInterrupt();
    7e9c:	c6 df       	rcall	.-116    	; 0x7e2a <_Z19USBGeneralInterruptv>
	UEDATX = d;
}

static inline void SetEP(u8 ep)
{
	UENUM = ep;
    7e9e:	10 93 e9 00 	sts	0x00E9, r17
	UECONX = (1<<STALLRQ) | (1<<EPEN);
}

static inline u8 ReadWriteAllowed()
{
	return UEINTX & (1<<RWAL);
    7ea2:	80 91 e8 00 	lds	r24, 0x00E8
	{
		USBSetupInterrupt();
		USBGeneralInterrupt();

		//	Read a char
		if (HasData(CDC_RX))
    7ea6:	85 ff       	sbrs	r24, 5
    7ea8:	13 c0       	rjmp	.+38     	; 0x7ed0 <_Z10USBGetCharv+0x42>
		*data++ = UEDATX;
}

static inline u8 Recv8()
{
	RXLED1;					// light the RX LED
    7eaa:	28 98       	cbi	0x05, 0	; 5
	RxLEDPulse = TX_RX_LED_PULSE_MS;
    7eac:	84 e6       	ldi	r24, 0x64	; 100
    7eae:	80 93 8d 01 	sts	0x018D, r24
	return UEDATX;
    7eb2:	90 91 f1 00 	lds	r25, 0x00F1
	UECONX = (1<<STALLRQ) | (1<<EPEN);
}

static inline u8 ReadWriteAllowed()
{
	return UEINTX & (1<<RWAL);
    7eb6:	80 91 e8 00 	lds	r24, 0x00E8

		//	Read a char
		if (HasData(CDC_RX))
		{
			u8 c = Recv8();
			if (!ReadWriteAllowed())
    7eba:	85 fd       	sbrc	r24, 5
    7ebc:	03 c0       	rjmp	.+6      	; 0x7ec4 <_Z10USBGetCharv+0x36>
	return UEINTX & (1<<FIFOCON);
}

static inline void ReleaseRX()
{
	UEINTX = 0x6B;	// FIFOCON=0 NAKINI=1 RWAL=1 NAKOUTI=0 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=1
    7ebe:	8b e6       	ldi	r24, 0x6B	; 107
    7ec0:	80 93 e8 00 	sts	0x00E8, r24
		
		_delay_us(100);	// stretch out the bootloader period to about 5 seconds after enumeration
		LEDPulse();
	}
	return -1;
}
    7ec4:	89 2f       	mov	r24, r25
    7ec6:	90 e0       	ldi	r25, 0x00	; 0
    7ec8:	df 91       	pop	r29
    7eca:	cf 91       	pop	r28
    7ecc:	1f 91       	pop	r17
    7ece:	08 95       	ret
			if (!ReadWriteAllowed())
				ReleaseRX();
			return c;
		} 

		if (!--_timeout) {
    7ed0:	80 91 90 01 	lds	r24, 0x0190
    7ed4:	90 91 91 01 	lds	r25, 0x0191
    7ed8:	01 97       	sbiw	r24, 0x01	; 1
    7eda:	90 93 91 01 	sts	0x0191, r25
    7ede:	80 93 90 01 	sts	0x0190, r24
    7ee2:	80 91 90 01 	lds	r24, 0x0190
    7ee6:	90 91 91 01 	lds	r25, 0x0191
    7eea:	89 2b       	or	r24, r25
    7eec:	09 f4       	brne	.+2      	; 0x7ef0 <_Z10USBGetCharv+0x62>
			Reboot();	// USB not connected, run firmware
    7eee:	41 dd       	rcall	.-1406   	; 0x7972 <_Z6Rebootv>
    7ef0:	ce 01       	movw	r24, r28
    7ef2:	01 97       	sbiw	r24, 0x01	; 1
    7ef4:	f1 f7       	brne	.-4      	; 0x7ef2 <_Z10USBGetCharv+0x64>
		}
		
		_delay_us(100);	// stretch out the bootloader period to about 5 seconds after enumeration
		LEDPulse();
    7ef6:	22 dd       	rcall	.-1468   	; 0x793c <_Z8LEDPulsev>
    7ef8:	d0 cf       	rjmp	.-96     	; 0x7e9a <_Z10USBGetCharv+0xc>
